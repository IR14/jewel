def workpiece_length():      
    """
    Считывает с клавиатуры:
        1. внутренний диаметр кольца (размер кольца)
        2. высоту заготовки (толщину кольца)
    Возвращает длину заготовки.
    """
    while True: # эти циклы объяснены в функции пониже, а вообще думаю их надо выделить в отдельную функцию проверки значений
        try:
            D_in = float(input('Введите размер кольца:'))
            if D_in > 0:
                break
            else:
                raise ValueError
        except ValueError:
            print('Данные некорректны, повторите ввод.')
    
    while True:
        try:
            h = float(input('Введите толщину вашей заготовки в мм:'))
            if h > 0:
                break
            else:
                raise ValueError
        except ValueError:
            print('Данные некорректны, повторите ввод.')

    l = (3.1416 * (D_in + h)) # берем средний диаметр из расчета погрешности
    print('Длина вашей заготовки равна:', '%.2f' % l, 'мм')
    return l

def wax_weight():
    """
    Считывает с клавиатуры:
        1. вес восковки (мастер модели)
        2. код металла для отливки изделия
    Возвращает что?.
    """
    while True: # пока истина делаем
        try: # пытаемся считать число с плавающей точкой
            wax = float(input('Введите вес мастер модели:'))
            if wax > 0: # если число больше 0 (а вес должен быть строго больше 0)
                break # то выходим из цикла с полученным числом
            else:
                raise ValueError # иначе искусственно вызываем ошибку ValueError, т.к. в остальных случаях она будет и так
        except ValueError: # это ошибка неправильного типа данны, например, если ввели вместо числа букву, то выдаст ошибку
            print('Данные некорректны, повторите ввод.') # говорим пользователю общую фразу что он натворил, дурачок
    
    # вот так должны выглядеть словари, по индексам вровень, Серебру соответствует вес 11 и код ar и так далее...
    elements = {'metals': ['Серебро', 'Медь', 'Платина', 'Бронза', 'Латунь', 'Золото 375', 'Золото 585', 'Золото 750'],
                'weight': [11, 8.93, 21.45, 8.9, 8.5, 11.5, 14, 17],
                'code': ['ar', 'c', 'p', 'b', 'l', 'au1', 'au2', 'au3']}
    
    print('Металлы и их коды, представленные в скобках:')
    for i in range(len(help['code'])):
        print(help['metals'][i], '(%s)' % help['code'][i])
    
    while True: # тут весь цикл такой же, как и с wax'ом, ток условие проверки другое
        try:
            element = input('Введите код металла металла, в котором будет отливаться изделие:')
            if help['code'].count(element) != 0: # проверяем, что введенный код вообще есть в списке кодов
                break
            else:
                raise ValueError
        except ValueError:
            print('Код металла не распознан, повторите ввод.')
    
    # тут мозг ломается, но я объясню:
    # help['weight'] - названия металлов, тогда, например, help['weight'][0] - это Серебро
    # но вместо обычного 0 нам нужно запихнуть индекс кода, т.к. по индексу кода можно узнать и вес, и металл
    # help['code'].index(element) - вернет индекс element в списке help['code']
    # значит help['weight'][help['code'].index(element)] - это удельная плотность введенного металла
    return (wax * help['weight'][help['code'].index(element)]) # о да, сама гениальность

print('Вас приветствует самопальная программа выполненная двумя энтузиастами.\n',
      'Выберите цифру, которая соответсвует вашему выбору.\n',
       '1. Узнать длину заготовки(кольца).\n',
       '2. Пересчет массы восковки в массу металла.', sep = '')

while True:
    try:
        num = int(input('Ввведите цифру:'))
        if num > 0:
            break
        else:
            raise ValueError
    except ValueError:
        print('Данные некорректны, повторите ввод.')

if num == 1:
    length = workpiece_length()
elif num ==2:
    weigth = wax_weight()
