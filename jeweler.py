def input_check(x, type_x, condition, input_txt, err_txt):
    """
    На входе функция принимает:
        1. x - переменная, ввод которой осуществляется
        2. type_x - тип переменной (напр. 'float' или 'int')
        3. condition - условие (в выражении используется локальная переменная)
        4. input_txt - что должно вывести при вводе
        5. err_txt - что должно вывести при ошибке
    На выходе возвращается введенная переменная по заданным условиям.
    """
    while True:
        try:
            x = eval(type_x)(input(input_txt))
            if eval(condition):
                return x
            else:
                raise ValueError
        except ValueError:
            print(err_txt)

def workpiece_length():      
    """
    Считывает с клавиатуры:
        1. внутренний диаметр кольца (размер кольца)
        2. высоту заготовки (толщину кольца)
    Возвращает длину заготовки.
    """
    D_in = None
    D_in = input_check(D_in, 'float', 'x > 0', 'Введите размер кольца:', 'Данные некорректны, повторите ввод.')
    
    h = None
    h = input_check(h, 'float', 'x > 0', 'Введите толщину вашей заготовки в мм:', 'Данные некорректны, повторите ввод.')

    l = (3.1416 * (D_in + h)) # берем средний диаметр из расчета погрешности
    print('Длина вашей заготовки равна:', '%.2f' % l, 'мм')
    return l

def wax_weight():
    """
    Считывает с клавиатуры:
        1. вес восковки (мастер модели)
        2. код металла для отливки изделия
    Возвращает массу металла, требуемую на определенную восковку.
    """
    wax = None
    wax = input_check(wax, 'float', 'x > 0', 'Введите вес мастер модели:', 'Данные некорректны, повторите ввод.')
    
    # вот так должны выглядеть словари, по индексам вровень, Серебру соответствует вес 11 и код ar и так далее...
    elements = {'metals': ['Серебро', 'Медь', 'Платина', 'Бронза', 'Латунь', 'Золото 375', 'Золото 585', 'Золото 750'],
                'weight': [11, 8.93, 21.45, 8.9, 8.5, 11.5, 14, 17],
                'code': ['ar', 'c', 'p', 'b', 'l', 'au1', 'au2', 'au3']}
    
    print('Металлы и их коды, представленные в скобках:\n')
    for i in range(len(elements['code'])):
        print(elements['metals'][i], '(%s)' % elements['code'][i])

    while True: # тут весь цикл такой же, как и с wax'ом, ток условие проверки другое
        try:
            element = input('Введите код металла металла, в котором будет отливаться изделие:')
            if elements['code'].count(element) != 0: # проверяем, что введенный код вообще есть в списке кодов
                break
            else:
                raise ValueError
        except ValueError:
            print('Код металла не распознан, повторите ввод.')
    
    # тут мозг ломается, но я объясню:
    # elements['weight'] - названия металлов, тогда, например, elements['weight'][0] - это Серебро
    # но вместо обычного 0 нам нужно запихнуть индекс кода, т.к. по индексу кода можно узнать и вес, и металл
    # elements['code'].index(element) - вернет индекс element в списке elements['code']
    # значит elements['weight'][elements['code'].index(element)] - это удельная плотность введенного металла
    print('\nМасса металла, требуемая на определенную восковку:', '%.2f' % (wax * elements['weight'][elements['code'].index(element)]))
    return (wax * elements['weight'][elements['code'].index(element)]) # о да, сама гениальность

print('Вас приветствует самопальная программа выполненная двумя энтузиастами.\n',
      'Выберите цифру, которая соответсвует вашему выбору.\n',
       '1. Узнать длину заготовки(кольца).\n',
       '2. Пересчет массы восковки в массу металла.\n', sep = '')

num = None
num = input_check(num, 'int', 'x in (1, 2)', 
                  'Ввведите цифру:',
                  'Данные некорректны, повторите ввод.')

if num == 1:
    length = workpiece_length()
elif num == 2:
    weigth = wax_weight()
